<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 新年盛典 - 倒计时与烟花融合版</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Ma+Shan+Zheng&family=Orbitron:wght@700&display=swap" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: #050505;
            overflow: hidden;
            font-family: 'sans-serif';
            cursor: pointer;
        }

        /* 两个Canvas层叠 */
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* 烟花在底层 */
        #canvas-fireworks { z-index: 1; }
        
        /* 文字在顶层 */
        #canvas-text { z-index: 2; pointer-events: none; /* 让点击穿透到底层 */ }

        #hint {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.5rem;
            letter-spacing: 4px;
            pointer-events: none;
            z-index: 10;
            animation: pulse 2s infinite;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            font-family: 'Ma Shan Zheng', cursive;
            transition: opacity 0.5s;
        }

        @keyframes pulse {
            0% { opacity: 0.4; }
            50% { opacity: 1; }
            100% { opacity: 0.4; }
        }
    </style>
</head>
<body>

    <div id="hint">点击屏幕 开启 2026</div>
    
    <canvas id="canvas-fireworks" class="canvas-layer"></canvas>
    <canvas id="canvas-text" class="canvas-layer"></canvas>

<script>
/**
 * -----------------------------------------------------------------------
 * 全局控制器
 * -----------------------------------------------------------------------
 */
let isRunning = false;
let width, height;

// 获取画布上下文
const fwCanvas = document.getElementById('canvas-fireworks');
const fwCtx = fwCanvas.getContext('2d');

const textCanvas = document.getElementById('canvas-text');
const textCtx = textCanvas.getContext('2d');

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    fwCanvas.width = width;
    fwCanvas.height = height;
    textCanvas.width = width;
    textCanvas.height = height;
}
window.addEventListener('resize', resize);
resize();


/**
 * =======================================================================
 * 部分 I: 烟花系统 (Firework System)
 * =======================================================================
 */
const FW_CONFIG = {
    // ================= 核心发射控制 =================
    spawnInterval: 100,      // [发射速度] 多少帧发射一次 (60约等于1秒)。数值越大，发射越慢；数值越小，发射越密集。
    concurrentSpawns: 1,    // [并发数量] 每次触发发射时，同时升空几枚烟花。

    // ================= 烟花样式概率 (权重系统) =================
    // 原理：程序会将下面5个数值相加，数值越大，该样式出现的概率越高
    styleConfig: {
        single: 100,        // [单色烟花] 普通纯色烟花的出现权重
        mixed: 25,          // [混色烟花] 粒子颜色随机混合的权重
        split: 0,           // [双色烟花] 左右两半颜色不同的权重
        child: 15,          // [子母烟花] 炸开后会射出小弹头进行二次爆炸的权重
        flash: 25,          // [闪光烟花] 炸开后会先变暗、悬浮，然后猛烈闪光的权重
        colorOffsetMin: 30, // [混色跨度] 双色模式下，第二种颜色与主颜色的最小色相差值
        colorOffsetMax: 80 // [混色跨度] 双色模式下，第二种颜色与主颜色的最大色相差值
    },

    // ================= 闪光(Flash)烟花专用配置 =================
    flashConfig: {
        hue: { 
            min: 40,        // [闪光颜色] 闪光粒子的色相最小值 (40-50为金黄色)
            max: 50         // [闪光颜色] 闪光粒子的色相最大值
        },
        dimRate: 0.01,      // [变暗速度] 爆炸后粒子变暗变透明的速度 (越小越慢)
        triggerAlpha: 0.3,  // [触发亮度] 当粒子透明度降到这个值以下时，开始准备闪光
        stagger: 30,        // [闪烁错落] 粒子闪光的随机延迟范围 (值越大，闪烁越参差不齐，越有星光感)
        dormantAlpha: 0.1,  // [潜伏亮度] 等待闪光时的最低亮度 (设得低就像隐形了一样)
        flashBrightness: 1.0, // [闪光亮度] 闪光爆发时的最大不透明度
        flashDecay: 0.03,   // [闪光消逝] 闪光后的消失速度 (值越大消失越快，像频闪；值越小越柔和)
        flashSizeMult: 0.6    // [闪光膨胀] 闪光时粒子瞬间放大的倍数
    },

    // ================= 子母(Child)烟花专用配置 =================
    childConfig: {
        count: { 
            min: 50,        // [子弹数量] 第一次爆炸释放的小弹头最少数量
            max: 120        // [子弹数量] 第一次爆炸释放的小弹头最多数量
        },
        spreadSpeed: 20,    // [扩散速度] 小弹头向外飞行的初速度 (决定了第二圈有多大)
        gravity: 0.015,     // [子弹重力] 小弹头下坠的重力感 (值越大下坠越快)
        waitFrames: { 
            min: 35,        // [二次引信] 小弹头飞多久后进行二次爆炸 (最小值)
            max: 60         // [二次引信] 小弹头飞多久后进行二次爆炸 (最大值)
        },
        subExplosionSize: 0.6, // [二爆力度] 第二次爆炸的粒子扩散速度倍率
        subDensity: 0.5     // [二爆密度] 第二次爆炸产生的粒子数量倍率
    },

    // ================= 通用物理与视觉参数 =================
    riseSpeed: { 
        min: 7,             // [升空速度] 烟花升空的最小速度
        max: 11             // [升空速度] 烟花升空的最大速度
    },
    targetHeight: 0.70,     // [爆炸高度] 烟花在屏幕高度的百分之几处爆炸 (0.70表示从底向上飞70%的高度)
    
    explosionSpeed: { 
        min: 2.5,             // [爆炸力度] 粒子炸开的最小初速度 (控制爆炸半径)
        max: 5              // [爆炸力度] 粒子炸开的最大初速度
    },
    
    gravity: 0.015,         // [粒子重力] 爆炸后粒子下坠的力度
    friction: 0.98,         // [空气阻力] 粒子减速系数 (1.0是不减速，0.9越小阻力越大，爆炸范围越小)
    
    alphaDecay: { 
        min: 0.01,          // [消失速度] 粒子自然消逝的最慢速度
        max: 0.016          // [消失速度] 粒子自然消逝的最快速度
    },
    
    explosionDensity: 2,  // [粒子总数] 控制爆炸产生的粒子总密度 (数值越大越密集，卡顿风险越高)
    trailDensity: 2,        // [尾焰密度] 升空时的尾巴浓淡 (1为稀疏，3为浓密)
    
    particleSize: { 
        min: 1,             // [粒子大小] 爆炸粒子的最小直径
        max: 1.8              // [粒子大小] 爆炸粒子的最大直径 (想让烟花点变大改这里)
    }
};

const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));
function random(min, max) { return Math.random() * (max - min) + min; }

// --- 烟花专用粒子类 (FwParticle) ---
class FwParticle {
    constructor(x, y, color, velocity, options = {}) {
        this.x = x; this.y = y; this.color = color;
        this.vx = velocity.x; this.vy = velocity.y;
        this.alpha = 1;
        this.friction = options.friction || FW_CONFIG.friction;
        this.gravity = options.gravity || FW_CONFIG.gravity;
        this.decay = options.decay || random(FW_CONFIG.alphaDecay.min, FW_CONFIG.alphaDecay.max);
        this.size = options.size || random(FW_CONFIG.particleSize.min, FW_CONFIG.particleSize.max);
        
        // 闪光逻辑
        this.isFlashParticle = options.isFlashParticle || false;
        this.hasFlashed = false;
        this.waitingForFlash = false;
        this.flashWaitTimer = 0;
    }

    update() {
        this.vx *= this.friction; this.vy *= this.friction; this.vy += this.gravity;
        this.x += this.vx; this.y += this.vy;

        if (this.isFlashParticle) {
            if (this.hasFlashed) {
                this.alpha -= this.decay;
            } else if (this.waitingForFlash) {
                this.alpha = FW_CONFIG.flashConfig.dormantAlpha;
                this.flashWaitTimer--;
                if (this.flashWaitTimer <= 0) {
                    this.hasFlashed = true;
                    this.waitingForFlash = false;
                    this.alpha = FW_CONFIG.flashConfig.flashBrightness;
                    this.decay = FW_CONFIG.flashConfig.flashDecay;
                    this.size *= FW_CONFIG.flashConfig.flashSizeMult;
                    this.color = `hsl(45, 100%, 90%)`;
                }
            } else {
                this.alpha -= this.decay;
                if (this.alpha < FW_CONFIG.flashConfig.triggerAlpha) {
                    this.waitingForFlash = true;
                    this.flashWaitTimer = Math.floor(Math.random() * FW_CONFIG.flashConfig.stagger);
                }
            }
        } else {
            this.alpha -= this.decay;
        }
    }

    draw(ctx) {
        if (this.alpha <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// --- 子弹头类 ---
class SubShell {
    constructor(x, y) {
        this.x = x; this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * FW_CONFIG.childConfig.spreadSpeed;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.hue = Math.floor(Math.random() * 360);
        this.color = `hsl(${this.hue}, 100%, 70%)`;
        this.timer = random(FW_CONFIG.childConfig.waitFrames.min, FW_CONFIG.childConfig.waitFrames.max);
        this.dead = false;
    }
    update() {
        this.vx *= 0.95; this.vy *= 0.95; this.vy += FW_CONFIG.childConfig.gravity;
        this.x += this.vx; this.y += this.vy;
        this.timer--;
        if (this.timer <= 0) { this.dead = true; this.explode(); }
    }
    draw(ctx) {
        ctx.save();
        ctx.fillStyle = this.color;
        const alpha = 0.5 + Math.cos(this.timer * 0.5) * 0.5;
        ctx.globalAlpha = alpha;
        ctx.beginPath(); ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }
    explode() {
        const count = Math.floor(100 * FW_CONFIG.childConfig.subDensity);
        const speedBase = random(2, 4) * FW_CONFIG.childConfig.subExplosionSize;
        for (let i = 0; i < count; i++) {
            const y_pos = 1 - (i / (count - 1)) * 2;
            const radius = Math.sqrt(1 - y_pos * y_pos);
            const theta = GOLDEN_ANGLE * i;
            fwParticles.push(new FwParticle(this.x, this.y, this.color, {
                x: Math.cos(theta) * radius * (speedBase + Math.random()*0.5),
                y: y_pos * (speedBase + Math.random()*0.5)
            }, { size: random(0.5, 0.9), decay: random(0.015, 0.025) }));
        }
    }
}

// --- 烟花火箭类 ---
class Firework {
    constructor(x) {
        this.x = x; this.y = height;
        this.targetY = height * (1 - FW_CONFIG.targetHeight) + random(-100, 100);
        this.speed = random(FW_CONFIG.riseSpeed.min, FW_CONFIG.riseSpeed.max);
        this.vx = 0; this.vy = -this.speed;
        this.hue = Math.floor(Math.random() * 360);
        this.color = `hsl(${this.hue}, 100%, 65%)`;
        this.dead = false;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.vy += 0.08;
        for(let i=0; i<FW_CONFIG.trailDensity; i++) {
            fwParticles.push(new FwParticle(this.x, this.y, this.color,
                { x: (Math.random()-0.5)*0.5, y: this.speed*0.15 + Math.random()*0.5 },
                { size: random(1, 2), gravity: 0.02, friction: 0.95, decay: random(0.08, 0.15) }
            ));
        }
        if (this.vy >= -0.5 || this.y <= this.targetY) {
            this.dead = true;
            createExplosion(this.x, this.y, this.hue);
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

// 烟花数据集合
let fireworks = [];
let subShells = [];
let fwParticles = [];
let fwTimer = 0;

function createExplosion(x, y, hue) {
    const s = FW_CONFIG.styleConfig;
    const total = s.single + s.mixed + s.split + s.child + s.flash;
    const r = Math.random() * total;
    let style = 'single';
    let acc = 0;
    acc += s.single; if (r < acc) style = 'single';
    else { acc += s.mixed; if (r < acc) style = 'mixed';
    else { acc += s.split; if (r < acc) style = 'split';
    else { acc += s.child; if (r < acc) style = 'child';
    else style = 'flash'; }}}

    if (style === 'child') {
        const childCount = random(FW_CONFIG.childConfig.count.min, FW_CONFIG.childConfig.count.max);
        for(let i=0; i<childCount; i++) subShells.push(new SubShell(x, y));
        return;
    }

    let color1 = `hsl(${hue}, 100%, 65%)`, color2;
    if (style === 'flash') {
        const flashHue = random(FW_CONFIG.flashConfig.hue.min, FW_CONFIG.flashConfig.hue.max);
        color1 = `hsl(${flashHue}, 100%, 60%)`; color2 = color1;
    } else {
        const offset = random(FW_CONFIG.styleConfig.colorOffsetMin, FW_CONFIG.styleConfig.colorOffsetMax);
        color2 = `hsl(${(hue + offset) % 360}, 100%, 65%)`;
    }

    const count = Math.floor(180 * FW_CONFIG.explosionDensity);
    const speedBase = random(FW_CONFIG.explosionSpeed.min, FW_CONFIG.explosionSpeed.max);
    
    for (let i = 0; i < count; i++) {
        const y_pos = 1 - (i / (count - 1)) * 2;
        const radius = Math.sqrt(1 - y_pos * y_pos);
        const theta = GOLDEN_ANGLE * i;
        const speed = speedBase + Math.random() * 1.0;
        let pColor = color1;
        if (style === 'mixed') pColor = Math.random() < 0.5 ? color1 : color2;
        else if (style === 'split') pColor = y_pos > 0 ? color1 : color2;

        fwParticles.push(new FwParticle(x, y, pColor, 
            { x: Math.cos(theta) * radius * speed, y: y_pos * speed }, 
            { isFlashParticle: (style === 'flash'), decay: (style === 'flash') ? FW_CONFIG.flashConfig.dimRate : undefined }
        ));
    }
}

// 烟花循环帧
function animateFireworks() {
    if (!isRunning) return;

    // 清除画布 (带拖尾)
    fwCtx.globalCompositeOperation = 'destination-out';
    fwCtx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
    fwCtx.fillRect(0, 0, width, height);
    fwCtx.globalCompositeOperation = 'lighter';

    // 更新绘制
    for (let i = fireworks.length - 1; i >= 0; i--) {
        fireworks[i].update(); fireworks[i].draw(fwCtx);
        if (fireworks[i].dead) fireworks.splice(i, 1);
    }
    for (let i = subShells.length - 1; i >= 0; i--) {
        subShells[i].update(); subShells[i].draw(fwCtx);
        if (subShells[i].dead) subShells.splice(i, 1);
    }
    for (let i = fwParticles.length - 1; i >= 0; i--) {
        fwParticles[i].update(); fwParticles[i].draw(fwCtx);
        if (fwParticles[i].alpha <= 0) fwParticles.splice(i, 1);
    }

    // 发射逻辑
    fwTimer++;
    if (fwTimer >= FW_CONFIG.spawnInterval) {
        for(let i=0; i<FW_CONFIG.concurrentSpawns; i++) {
             fireworks.push(new Firework(random(width * 0.2, width * 0.8)));
        }
        fwTimer = 0;
    }
    
    requestAnimationFrame(animateFireworks);
}


/**
/**
 * =======================================================================
 * 部分 II: 文字粒子系统 (Text Particle System)
 * =======================================================================
 */

// 1. 判断是否为手机 (屏幕宽度小于 800 视为手机/竖屏设备)
const isMobile = window.innerWidth < 800;

const TEXT_CONFIG = {
    // ▼▼▼▼▼▼ 核心修改在这里 ▼▼▼▼▼▼
    // 如果是手机，粒子大小设为 1.0 (电脑是 3.0)
    particleSize: isMobile ? 1.0 : 3.0, 
    
    // 如果是手机，粒子间距设为 5 (电脑是 10)
    // 解释：手机屏幕小，必须缩小间距，否则字会因为太宽而显示不全
    particleGap: isMobile ? 5 : 10,
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    bloomScaleMin: 1.5, bloomScaleMax: 2.2,
    bloomAlphaMin: 0.3, bloomAlphaMax: 0.6,
    dyingScatterSpeed: 0.01, dyingFadeSpeed: 0.005,
    rebirthMoveSpeed: 0.05, rebirthStartSize: 8.0, rebirthStartAlpha: 0.4,
    fontName: 'Roboto',
    // 注意：前5个是倒计时，2026开始是正式烟花
    textList: ['5', '4', '3', '2', '1', '2026', '新年快乐', '新的一年', '祝周佳纯', '心想事成', '万事胜意', '好运+n', '幸福+n', '健康+n', '快乐+n'], 
    normalAlpha: 1.0
};
let textParticles = []; 
let isTextEnded = false;

const STATUS = { ACTIVE: 'active', DYING: 'dying', IDLE: 'idle' };

class TextParticle {
    constructor(x, y) {
        this.x = x; this.y = y; this.tx = x; this.ty = y;
        this.size = TEXT_CONFIG.particleSize; this.targetSize = TEXT_CONFIG.particleSize;
        this.alpha = 0; this.targetAlpha = TEXT_CONFIG.normalAlpha;
        this.status = STATUS.IDLE; this.ease = 0.15;
    }

    update() {
        this.x += (this.tx - this.x) * this.ease;
        this.y += (this.ty - this.y) * this.ease;
        this.size += (this.targetSize - this.size) * 0.1;

        if (this.status === STATUS.ACTIVE) {
            this.alpha += (this.targetAlpha - this.alpha) * 0.1;
        } else if (this.status === STATUS.DYING) {
            if (this.alpha > 0) {
                this.alpha -= TEXT_CONFIG.dyingFadeSpeed;
                if (this.alpha < 0) this.alpha = 0;
            }
            if (this.size > 0) {
                this.size -= 0.1;
                if (this.size < 0) this.size = 0;
            }
            if (this.alpha <= 0 && this.size <= 0) this.status = STATUS.IDLE;
        }
    }

    draw() {
        if (this.alpha < 0.01) return;
        textCtx.beginPath();
        textCtx.arc(this.x, this.y, Math.max(0, this.size), 0, Math.PI * 2);
        textCtx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
        textCtx.fill();
    }
}

function getTextCoordinates(text) {
    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');
    offCanvas.width = width;
    offCanvas.height = height;

    let fontSize = width > 800 ? 300 : 120;
    if (text.length > 3) fontSize = width > 800 ? 180 : 80; // 字多稍微小点
    
    offCtx.font = `bold ${fontSize}px "${TEXT_CONFIG.fontName}", sans-serif`;
    offCtx.fillStyle = '#FFFFFF';
    offCtx.textAlign = 'center';
    offCtx.textBaseline = 'middle';
    offCtx.fillText(text, width / 2, height / 2);

    const imageData = offCtx.getImageData(0, 0, width, height).data;
    const coords = [];
    for (let y = 0; y < height; y += TEXT_CONFIG.particleGap) {
        for (let x = 0; x < width; x += TEXT_CONFIG.particleGap) {
            if (imageData[(y * width + x) * 4 + 3] > 128) coords.push({ x: x, y: y });
        }
    }
    return coords;
}

function mapParticlesToText(text) {
    const coords = getTextCoordinates(text);
    coords.sort(() => Math.random() - 0.5);

    const activeList = textParticles.filter(p => p.status === STATUS.ACTIVE);
    const idleOrDying = textParticles.filter(p => p.status !== STATUS.ACTIVE);

    coords.forEach((target, index) => {
        let p;
        if (index < activeList.length) {
            p = activeList[index];
            p.tx = target.x; p.ty = target.y;
            p.targetSize = TEXT_CONFIG.particleSize;
            p.targetAlpha = TEXT_CONFIG.normalAlpha;
            p.ease = 0.1;
        } else {
            if (idleOrDying.length > 0) p = idleOrDying.shift();
            else { p = new TextParticle(width/2, height/2); textParticles.push(p); }
            p.status = STATUS.ACTIVE;
            p.alpha = TEXT_CONFIG.rebirthStartAlpha; p.size = TEXT_CONFIG.rebirthStartSize;
            p.tx = target.x; p.ty = target.y;
            p.targetAlpha = TEXT_CONFIG.normalAlpha; p.targetSize = TEXT_CONFIG.particleSize;
            p.ease = TEXT_CONFIG.rebirthMoveSpeed;
        }
    });

    if (activeList.length > coords.length) {
        for (let i = coords.length; i < activeList.length; i++) {
            const p = activeList[i];
            p.status = STATUS.DYING;
            p.tx = Math.random() * width;
            p.ty = Math.random() * height;
            p.ease = TEXT_CONFIG.dyingScatterSpeed;
        }
    }
}

// 替换原有的 scatterTextParticles 函数
function scatterTextParticles() {
    isTextEnded = true; // 标记文案结束
    
    textParticles.forEach(p => {
        // 1. 关键：保持 ACTIVE 状态
        // 只有在 ACTIVE 状态下，粒子才会应用 targetAlpha 和 targetSize 的过渡效果
        p.status = STATUS.ACTIVE;

        // 2. 位置：扩散到整个屏幕范围
        p.tx = Math.random() * width;
        p.ty = Math.random() * height;

        // 3. 敏感度（明暗不一）：
        // 设置一个随机的目标透明度，例如 0.3 到 1.0 之间
        // 这样有的粒子亮，有的粒子暗
        p.targetAlpha = 0.1 + Math.random() * 0.5; 

        // 4. 大小不一：
        // 设置一个随机的目标大小，例如 1.0 到 5.0 之间
        // (原代码默认大小是 3.5)
        p.targetSize = 0.5 + Math.random() * 2.0;

        // 5. 飘散速度：
        // 设置一个小一点的值 (如 0.01)，让它们缓慢而优雅地飘向全屏，而不是瞬间闪现
        p.ease = 0.05; 
    });
}

// ----------------------
// 序列与联动控制核心
// ----------------------
let currentTextIndex = 0;
function nextTextSequence() {
    if (currentTextIndex >= TEXT_CONFIG.textList.length) {
        scatterTextParticles();
        return;
    }

    const text = TEXT_CONFIG.textList[currentTextIndex];
    mapParticlesToText(text);

    // ================= 联动逻辑 =================
    // 判断当前是否在倒计时阶段
    if (['5', '4', '3', '2', '1'].includes(text)) {
        // 倒计时阶段：烟花稀疏
        FW_CONFIG.spawnInterval = 60; // 较慢
        FW_CONFIG.concurrentSpawns = 1;
    } else {
        // 2026 及以后：火力全开
        FW_CONFIG.spawnInterval = 45; // 极快
        FW_CONFIG.concurrentSpawns = 2; // 每次发多颗
    }
    // ===========================================

// ================= 时间控制核心 =================
    // 定义两个变量：
    // 1. waitBeforeBloom: 文字聚合成形后，等待多久开始"变暗膨胀"
    // 2. stayTime: 变暗膨胀后，在屏幕上停留多久才切换下一个词
    
    let waitBeforeBloom = 800; 
    let stayTime = 900;

    // 判断当前文字是否为倒计时数字
    const isCountdown = ['5', '4', '3', '2', '1'].includes(text);

    if (isCountdown) {
        // --- 倒计时模式 (快) ---
        // 这里的总时间 (waitBeforeBloom + stayTime) 最好接近 1000ms (1秒)
        waitBeforeBloom = 900; // 聚拢后几乎立刻开始膨胀
        stayTime = 100;        // 停留0.9秒
    } else {
        // --- 文案模式 (慢) ---
        // 这里可以设置得很长，让你慢慢看
        waitBeforeBloom = 1750; // 字先定住 1.5秒 让人看清楚
        stayTime = 250;        // 膨胀效果再持续 2.5秒
        
        // 特殊处理：年份 '2026' 可以更久
        if (text === '2026') {
            waitBeforeBloom = 1750;
            stayTime = 250;
        }
    }
    // ===========================================

    // ▼▼▼ 注意：这里把原来的 800 改成了 waitBeforeBloom ▼▼▼
    setTimeout(() => {
        if (isTextEnded) return;
        
        // 执行变暗膨胀效果
        const activeList = textParticles.filter(p => p.status === STATUS.ACTIVE);
        activeList.forEach(p => {
            p.targetSize = TEXT_CONFIG.particleSize * random(TEXT_CONFIG.bloomScaleMin, TEXT_CONFIG.bloomScaleMax);
            p.targetAlpha = random(TEXT_CONFIG.bloomAlphaMin, TEXT_CONFIG.bloomAlphaMax);
        });

        // ▼▼▼ 注意：这里把原来的 delay 改成了 stayTime ▼▼▼
        setTimeout(() => {
            currentTextIndex++;
            nextTextSequence();
        }, stayTime);

    }, waitBeforeBloom);
}

function animateText() {
    if (!isRunning) return;
    
    // 清除方式：使用 destination-out 使得背景变透明，从而能看到底下的烟花
    // 同时保留一点点拖尾感 (alpha 0.2)
    textCtx.globalCompositeOperation = 'destination-out';
    textCtx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
    textCtx.fillRect(0, 0, width, height);
    textCtx.globalCompositeOperation = 'source-over'; // 恢复正常绘制

    textParticles.forEach(p => p.update());
    textParticles.forEach(p => p.draw());

    requestAnimationFrame(animateText);
}

// ----------------------
// 启动逻辑
// ----------------------
document.body.addEventListener('click', () => {
    if (isRunning) {
        // 允许点击屏幕任意位置放烟花
        return; 
    }
    isRunning = true;
    
    // UI 隐藏
    const hint = document.getElementById('hint');
    hint.style.opacity = 0;
    setTimeout(() => hint.style.display = 'none', 500);
    
    // 启动两个循环
    animateFireworks();
    animateText();
    
    // 开始序列
    nextTextSequence();
});

// 点击增加烟花互动
document.body.addEventListener('mousedown', (e) => {
    if(!isRunning) return;
    fireworks.push(new Firework(e.clientX));
});

</script>
</body>
</html>